import numpy as np
import cffi
import os
from awrams.utils.nodegraph import nodes
from awrams.utils import geo, extents
from awrams.utils.helpers import as_int
from awrams.utils.mapping_types import gen_coordset

ffi = cffi.FFI()
ffi.cdef("void undo_thing(double *in, double *out, int xn, int yn, int scalefac);")
ffi.cdef("void undo_thing3d(double *in, double *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void do_thing(double *in, double *out, int xn, int yn, int scalefac);")
ffi.cdef("void do_thing3d(double *in, double *out, int xn, int yn, int zn, int scalefac);")

ffi.cdef("void do_thing3d_d(double *in, double *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void do_thing3d_f(float *in, float *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void undo_thing3d_d(double *in, double *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void undo_thing3d_f(float *in, float *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void undo_thing3d_m_d(double *in, double *out, int xn, int yn, int zn, int scalefac);")
ffi.cdef("void undo_thing3d_m_f(float *in, float *out, int xn, int yn, int zn, int scalefac);")


_so_path = os.path.join(os.path.dirname(__file__),'rescale.so')

rlib = ffi.dlopen(_so_path)

def rescale_index(inshape,scalefac):
    '''
    Return a set of indices for nearest-neighbour upscaling
    '''
    nx,ny = inshape[0],inshape[1]
    return np.arange(nx).repeat(ny*scalefac*scalefac), np.tile(np.repeat(np.arange(ny),scalefac),nx*scalefac)

def _rescale_with(in_data,scalefac,outx,outy):
    '''
    Rescale in_data by scalefac, using indices generated by gen_rescale_indices
    '''
    read_idx = [] + [slice(None) for i in range(len(in_data.shape) - 2)] + [outx,outy]
    out_shape = tuple([] + [k for k in in_data.shape[:-2]] + [in_data.shape[-2]*scalefac,in_data.shape[-1]*scalefac])
    return in_data[read_idx].reshape(out_shape)
    #return in_data[outx,outy].reshape((in_data.shape[0]*scalefac,in_data.shape[1]*scalefac))

def upscale(in_data,scalefac):
    from awrams.models.awral import ffi_wrapper as fw #+++ refactor into FFI tools

    if not in_data.flags.c_contiguous:
        in_data = np.ascontiguousarray(in_data)

    in_f = fw.ccast(in_data,ffi,in_data.dtype)

    if len(in_data.shape) == 2:
        x = in_data.shape[0]
        y = in_data.shape[1]
        z = 1
        out_data = np.empty(shape=(x*scalefac,y*scalefac),dtype=in_data.dtype)
    elif len(in_data.shape) == 3:
        x = in_data.shape[1]
        y = in_data.shape[2]
        z = in_data.shape[0]
        out_data = np.empty(shape=(z,x*scalefac,y*scalefac),dtype=in_data.dtype)
    else:
        raise Exception("Unsupported number of dimensions", len(in_data.shape))
    
    out_f = fw.ccast(out_data,ffi,in_data.dtype)

    if in_data.dtype == np.float32:
        rlib.do_thing3d_f(in_f,out_f,x,y,z,scalefac)
    elif in_data.dtype == np.float64:
        rlib.do_thing3d_d(in_f,out_f,x,y,z,scalefac)    
    else:
        raise Exception("Unsupported dtype", in_data.dtype)


    return out_data

def downscale(in_data,scalefac,check_nan=True):
    from awrams.models.awral import ffi_wrapper as fw #+++ refactor into FFI tools

    if not in_data.flags.c_contiguous:
        in_data = np.ascontiguousarray(in_data)

    in_f = fw.ccast(in_data,ffi,in_data.dtype,False)

    if len(in_data.shape) == 2:
        x = as_int(in_data.shape[0]/scalefac)
        y = as_int(in_data.shape[1]/scalefac)
        z = 1
        out_data = np.empty(shape=(x,y),dtype=in_data.dtype)
    elif len(in_data.shape) == 3:
        x = as_int(in_data.shape[1]/scalefac)
        y = as_int(in_data.shape[2]/scalefac)
        z = in_data.shape[0]
        out_data = np.empty(shape=(z,x,y),dtype=in_data.dtype)
    else:
        raise Exception("Unsupported number of dimensions", len(in_data.shape))
    
    out_f = fw.ccast(out_data,ffi,in_data.dtype,False)

    if check_nan:
        ffunc = rlib.undo_thing3d_m_f
        dfunc = rlib.undo_thing3d_m_d
    else:
        ffunc = rlib.undo_thing3d_f
        dfunc = rlib.undo_thing3d_d

    if in_data.dtype == np.float32:
        ffunc(in_f,out_f,x,y,z,scalefac)
    elif in_data.dtype == np.float64:
        dfunc(in_f,out_f,x,y,z,scalefac)    
    else:
        raise Exception("Unsupported dtype", in_data.dtype)

    return out_data


def get_extent_scale_indices(source,target,with_index=False):
    scalefac = (source.cell_size/target.cell_size)
    if scalefac < 1.0:
        scalefac = 1.0/scalefac
    scalefac = as_int(scalefac)

    tbr = target.bounding_rect()
    subsource = source.factory.get_by_boundary_coords(*tbr)
    
    offset = target.geospatial_reference().to_mode(geo.GeoReferenceMode.CORNER).get_offset(subsource.geospatial_reference())

    offset = (0-offset[0],0-offset[1])

    if with_index:
        ri = rescale_index(subsource.shape,scalefac)
        return subsource,offset,scalefac,ri
    else:
        return subsource,offset,scalefac


class UpscalingNode(nodes.InputNode):
    def __init__(self,child,target_extent):
        #+++ Need target_extent for cell_size, but can problem move a lot of computation into init... refactor later
        self.child = nodes.GraphNode(**child).get_executor()
        cs = self.child.get_coords()
        if len(cs) == 2:
            self._idx = _2idx
        elif len(cs) == 3:
            self._idx = _3idx
        self.lat_orient = target_extent.geospatial_reference().lat_orient
        self.cell_size = target_extent.cell_size
        self.cextent = self.child.get_extent()#extents.from_latlons(cs.latitude.index,cs.longitude.index)
        #self.cextent = self.child.sfm.ref_ds.get_extent()
        
    def get_data(self,coords):
        origin = geo.GeoPoint.from_degrees(coords['latitude'][0],coords['longitude'][0])
        nlats,nlons = len(coords['latitude']), len(coords['longitude'])

        georef = geo.GeoReference(origin,nlats,nlons,self.cell_size,lat_orient=self.lat_orient)
    
        
        target = extents.Extent(georef)
        
        ss,offset,scalefac = get_extent_scale_indices(self.cextent,target)
        
        data = self.child.get_data(gen_coordset(coords['time'].index,ss))
        
        dres = upscale(data,scalefac)
        
        return self._idx(dres,offset,target)
        #return dres[:,offset[0]:offset[0]+target.shape[0],offset[1]:offset[1]+target.shape[1]]
        
    def get_dataspec(self):
        return self.child.get_dataspec()

class DownscalingNode(nodes.InputNode):
    #+++
    '''
    Currently not mask aware; will naively average cells even if they contain FillValue,
    '''
    def __init__(self,child,target_extent):
        self.child = nodes.GraphNode(**child).get_executor()
        self.lat_orient = target_extent.geospatial_reference().lat_orient
        self.cell_size = target_extent.cell_size
        self.cextent = self.child.get_extent()#extents.from_latlons(cs.latitude.index,cs.longitude.index)

    def get_data(self,coords):
        origin = geo.GeoPoint.from_degrees(coords['latitude'][0],coords['longitude'][0])
        nlats,nlons = len(coords['latitude']), len(coords['longitude'])

        georef = geo.GeoReference(origin,nlats,nlons,self.cell_size,lat_orient=self.lat_orient)
        
        target = extents.Extent(georef)
        
        ss,offset,scalefac = get_extent_scale_indices(self.cextent,target)
        
        data = self.child.get_data(gen_coordset(coords['time'].index,ss))
        
        dres = downscale(data,scalefac)
        
        return dres
        
    def get_dataspec(self):
        return self.child.get_dataspec()


def _2idx(data,offset,target):
    return data[offset[0]:offset[0]+target.shape[0],offset[1]:offset[1]+target.shape[1]]

def _3idx(data,offset,target):
    return data[:,offset[0]:offset[0]+target.shape[0],offset[1]:offset[1]+target.shape[1]]

def upscaling_node(existing,target_extent):
    return nodes.GraphNode('upscaling_node',UpscalingNode,out_type=existing.out_type,inputs=None,properties={'io': 'r'},\
         args=dict(child=existing.to_dict(),target_extent=target_extent))

def downscaling_node(existing,target_extent):
    return nodes.GraphNode('downscaling_node',DownscalingNode,out_type=existing.out_type,inputs=None,properties={'io': 'r'},\
         args=dict(child=existing.to_dict(),target_extent=target_extent))